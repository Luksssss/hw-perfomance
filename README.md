# Оборудование
* **CPU**: Intel Core i5-9400 CPU @ 2.90GHz; 6 ядер
* **RAM**: 16 ГБ (DDR4)
* **SSD**

**Строка запуска теста:** `go test ./ -bench Count -v -count 1 -cpuprofile cpu.out -memprofile mem.out -benchtime 10x`

# Результаты

|Вариант                 | ~Время, с | ~ns/op       | ~MB/s      | allocs/op |
|------------------------|-----------|---------------------------------------|
|Исходный                |    5.9    |  557700000   | 10.2       | 575660    |
|Итоговый вариант*       |    0.22   |    8140000   | 650        |  17858    |
|+инлайнинг `isNumber()` |    0.21   |    3320000   | 1550       |  17858    |

*`bytes.IndexByte()` не дал практически никакого прироста.

***
# ТЗ

Вашему вниманию предоставлен репозиторий, в котором есть функция `joinNumbers()` и вам предстоит ее оптимизировать.

## Что делает функция joinNumbers?
Перебирает JSON документы и делает конкатенацию всех чисел, обнаруженных в поле `message`. Числом считается любая непрерывная последовательность из знаков `0123456789`.

## Входные данные 
Слайс `[]byte` с JSON документами, разделенными переводом строки.

**Пример:**
```
{"message":"this is number 100 and 200", "any_other_key":"100500"}\n
{"message":"and this is number 300 and 400", "this is strange percent number":"72.98%"}\n
```

## Выходные данные 
Строка, содержащая в себе конкатенацию чисел, найденных в поле `message` во всех JSON документах. Числа должны разделяться знаком `,` и пробелом. 

**Пример:**
```
100, 200, 300, 400
```
  
## Задание
1. Проанализировать бенчмарк функции с помощью pprof.
2. Избавиться от лишних аллокаций.
3. Распараллелить. Использовать для этого каналы.
    1. Отправлять в канал сразу пачку логов (как в key-analyzer).
    2. Проверить, что после распараллеливания не появились новые аллокации.
4. Попробовать вместо `json/encoding` – https://github.com/vitkovskii/insane-json или https://github.com/valyala/fastjson. Избавиться от аллокаций при декодировании JSON.
5. Изучить вывод `go build -gcflags="-m" ./main.go`, понять какие функции инлайнятся/какие нет и почему.
6. Заинлайнить вручную функцию `isNumber()`.
7. Попробовать заменить `for _, n := range numberChars` на `if`.
8. Придумать еще какие-нибудь оптимизации *
9. Предоставить результаты бенчмарка до/после всех манипуляций, а так же исходный код.